behavior trCheckboxSelect
  on click
    document.getSelection().removeAllRanges()
    if not event.shiftKey
      take .select-tr-element from <tr/> in closest <table/> for me
      call setCheckboxes(me, 'toggle') unless event.target.tagName.toLowerCase() === 'a'
    else
      document.getSelection().removeAllRanges()
      get first .select-tr-element in closest <table/>
      if it
        set toggleTo to 'none'
        if checked of first .multiselect in it
          set toggleTo to 'all'
        end
        set selectedTrElement to it
        if it.rowIndex < my.rowIndex
          repeat while selectedTrElement.nextElementSibling
            set selectedTrElement to selectedTrElement.nextElementSibling
            call setCheckboxes(selectedTrElement, toggleTo)
            if selectedTrElement is me
              break
            end
          end
        else
          repeat while selectedTrElement.previousElementSibling
            call setCheckboxes(selectedTrElement, toggleTo)
            if selectedTrElement is me
              break
            end
            set selectedTrElement to selectedTrElement.previousElementSibling
          end
        end
      end
    end
  end
end

behavior buttonCheckHtmxResponse
  on htmx:afterRequest from closest <form/> to me
    if (closest <form/> to me) != (event.target) exit end
    set :_v to my textContent unless :_v
    if event.detail.successful then
      put `👍` into me
    else
      put `🤖 An error occured` into me
    end
    wait 1s
    put :_v into me
    set :_v to null
  end
end

behavior confirmButton
  init set :inner to my.innerHTML end
  on every click from me
    halt the event
  end
  on click[event.detail==1] from me queue none
    set x to 3
    repeat until x == 0
      put `Confirm ${x}x` into me
      wait for a click or 1500ms
      if the result's type is 'click'
        decrement x
      else
        put :inner into me
        exit
      end
    end
    put :inner into me
    trigger confirmedButton
  end
end

behavior inlineHtmxRename
  init
    set :_textContent to my.textContent
  end

  on click halt the event end

  on htmx:afterRequest
    if event.detail.successful == true
      set :_textContent to my.textContent
    end
    set my.textContent to :_textContent
  end

  on htmx:confirm(issueRequest)
    halt the event
    call confirm(`${:_textContent} to ${my.textContent}?`)
    if not result set my.textContent to :_textContent else issueRequest() end
  end

  on blur
    if my.textContent == '' set my.textContent to :_textContent then exit end
    if my.textContent == :_textContent exit end
    set @hx-vals to `{"${my @data-patch-parameter}": "${my.textContent}"}`
    trigger editContent on me
  end

  on keydown[keyCode == 13]
    me.blur()
    halt the event
  end
end

behavior bodydefault
  init set :reloadCounter to 1 end

  on htmx:wsError or htmx:wsClose
    set #ws-indicator's textContent to '⭕'
  end

  on forceReload
    trigger notification(
      title: 'Unlocked session',
      level: 'user',
      message: `Preventing window reload due to unlocked session (keep pressing to force reload)`,
      duration: 2000,
      locations: []
    )
    wait for a forceReload or 400ms
    if result's type is 'forceReload'
      increment :reloadCounter
      log :reloadCounter
    else
      set :reloadCounter to 1
    end
  end

  on keydown
    exit unless window.vault.isUnlocked()
    if navigator.platform.toUpperCase().indexOf('MAC') >= 0
      set ctrlOrCmd to event.metaKey
    else
      set ctrlOrCmd to event.ctrlKey
    end
    if (event.key is "F5" or (ctrlOrCmd and event.key.toLowerCase() === "r")) or ((ctrlOrCmd and event.shiftKey and event.key.toLowerCase() === "r") or (event.shiftKey and e.key === "F5"))
      trigger forceReload
      if :reloadCounter < 2
        halt the event
      end
    end
  end

  on htmx:responseError
    set status to event.detail.xhr.status
    if status >= 500
      trigger notification(title: 'Server error', level: 'error', message: 'The server could not handle the given request', duration: 10000)
    else if status == 404
      trigger notification(title: 'Not found', level: 'error', message: `Route not found: ${event.detail.xhr.responseURL}`, duration: 3000)
    end
  end

  on htmx:configRequest
    if window.vault.isUnlocked()
      repeat for p in event.detail.parameters
        log p
      end
    end
  end

  on htmx:beforeRequest
    get closest <form/> to event.target
      if it
        remove @aria-invalid from <[aria-invalid]/> in it
      else
        remove @aria-invalid from <[aria-invalid]/>
      end
  end
end

behavior addPasskey(register)
  on submit
    halt the event
    add @disabled to <button/> in me
    postForm('/auth/register/webauthn/options', me)
    if result.ok
      call SimpleWebAuthnBrowser.startRegistration(result.text() as Object)
      fetch '/auth/register/webauthn/verify' as response with method:'POST', body: result as JSON, headers:{content-type:'application/json'}
      if result.ok
        if not register
          trigger notification(
            level: 'success',
            title: '{{ L["Passkey registered"] }}',
            message: '{{ L["New passkey was successfully registered"] }}',
            duration: 3000
          )
          call htmx.ajax('GET', '/profile/', {target:'#body-main'})
        else
          trigger notification(
            level: 'success',
            title: '{{ L["Welcome on board 👋"] }}',
            message: '{{ L["Your account was created, you can now log in"] }}',
            duration: 7000
          )
          remove @disabled from <button/> in me
          trigger click on <.login-register:not([hidden])/>
        end
      else
        throw(result.text())
      end
    else
      throw(result.text())
    end
  end
  on exception(error)
    trigger notification(level: 'error', title: 'Passkey error', message: error, duration: 3000) on body
    remove @disabled from <button/> in me
  end
end

behavior login
  on submit
    halt the event
    add @disabled to <button/> in me
    postForm('/auth/login/webauthn/options', me)
    if result.ok
      call SimpleWebAuthnBrowser.startAuthentication(result.text() as Object)
      fetch '/auth/login/webauthn/verify' as response with method:'POST', body: result as JSON, headers:{content-type:'application/json'}
      if result.ok and result.status == 202
        trigger proxyAuthSuccess on body
      else if result.ok
        go to url '/profile/'
      else
        throw(result.text())
      end
    else
      throw(result.text())
    end
  end
  on exception(error)
    trigger notification(level: 'error', title: 'Login failed', message: error, duration: 3000)
    remove @disabled from <button/> in me
  end
end

behavior objectFilters(submitForm)
  init
    hide <.filter-button:not(.active)/> in me
    remove @hidden from .filter-buttons in me
  end

  on keyup from .filter-input in me
    set filterButtons to (.filter-buttons in me)
    if event.target's value is ''
      hide <.filter-button:not(.active)/> in filterButtons
    else
      show <.filter-button/> in filterButtons when its textContent.toLowerCase() contains event.target.value.toLowerCase()
    end
    show <.filter-button.active/> in filterButtons
    if event.keyCode is 13
      repeat for button in <.filter-button:not(.active)/> in filterButtons
        if button's *display is not 'none' trigger click on it break end
      end
    end
  end

  on click from .filter-button in me
      halt the event
      set filterButtons to .filter-buttons
      put '' into #table-filters

      repeat for btn in (.filter-button in filterButtons)
        if (btn is event.target and btn does not match .active) or (btn is not event.target and btn matches .active)
          render #table-filter-item with (value: btn's value)
          then put the result at the end of #table-filters
        end
      end

      if length of <#table-filters input/> is 0
        render #table-filter-item with (value: '')
        then put the result at the end of #table-filters
      end

      trigger submit on submitForm unless submitForm == ''
  end
end

def setCheckboxes(el, option)
  if (length of <input[type='checkbox'].multiselect:checked/> in el) != 0 and (length of <input[type='checkbox'].multiselect/> in el) > 1 and option == 'toggle'
    set option to 'none'
  end
  repeat for e in (<input[type='checkbox'].multiselect/> in el)
    if option == 'all'
      set e's @checked to 'true'
      set e.checked to true
    else if option == 'none'
      remove @checked from e
      set e.checked to false
    else if option == 'invert'
      if e.checked
        toggle [@checked='false'] on e
        set e.checked to false
      else
        toggle [@checked='true'] on e
        set e.checked to true
      end
    else if option == 'toggle'
      toggle [@checked='true'] on e
      if e's @checked set e.checked to true else set e.checked to false end
    end
  end
end

def postJson(url, dataObject)
  fetch `${url}` as response with method:'POST', body:dataObject as JSON, headers:{content-type:'application/json'}
  return result
end

def postForm(url, form)
  js(form) return new URLSearchParams(new FormData(form)).toString() end
  fetch `${url}` as response with method:'POST', body: it, headers:{content-type:'application/x-www-form-urlencoded'}
  return result
end
